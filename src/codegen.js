/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
"use strict";
/**
 * Transform template html and css into executable code.
 * Intended to be used in a build step.
 */
const compiler = require('@angular/compiler');
const fs_1 = require('fs');
const path = require('path');
const compiler_host_1 = require('./compiler_host');
const path_mapped_compiler_host_1 = require('./path_mapped_compiler_host');
const GENERATED_FILES = /\.ngfactory\.ts$|\.ngstyle\.ts$/;
const GENERATED_META_FILES = /\.json$/;
const GENERATED_OR_DTS_FILES = /\.d\.ts$|\.ngfactory\.ts$|\.ngstyle\.ts$/;
const PREAMBLE = `/**
 * @fileoverview This file is generated by the Angular 2 template compiler.
 * Do not edit.
 * @suppress {suspiciousCode,uselessCode,missingProperties}
 */
 /* tslint:disable */

`;
class CodeGenerator {
    constructor(options, program, host, compiler, ngCompilerHost) {
        this.options = options;
        this.program = program;
        this.host = host;
        this.compiler = compiler;
        this.ngCompilerHost = ngCompilerHost;
    }
    // Write codegen in a directory structure matching the sources.
    calculateEmitPath(filePath) {
        let root = this.options.basePath;
        for (const eachRootDir of this.options.rootDirs || []) {
            if (this.options.trace) {
                console.error(`Check if ${filePath} is under rootDirs element ${eachRootDir}`);
            }
            if (path.relative(eachRootDir, filePath).indexOf('.') !== 0) {
                root = eachRootDir;
            }
        }
        // transplant the codegen path to be inside the `genDir`
        let relativePath = path.relative(root, filePath);
        while (relativePath.startsWith('..' + path.sep)) {
            // Strip out any `..` path such as: `../node_modules/@foo` as we want to put everything
            // into `genDir`.
            relativePath = relativePath.substr(3);
        }
        return path.join(this.options.genDir, relativePath);
    }
    codegen() {
        return this.compiler
            .compileAll(this.program.getSourceFiles().map(sf => this.ngCompilerHost.getCanonicalFileName(sf.fileName)))
            .then(generatedModules => {
            generatedModules.forEach(generatedModule => {
                const sourceFile = this.program.getSourceFile(generatedModule.srcFileUrl);
                const emitPath = this.calculateEmitPath(generatedModule.genFileUrl);
                const source = GENERATED_META_FILES.test(emitPath) ? generatedModule.source :
                    PREAMBLE + generatedModule.source;
                this.host.writeFile(emitPath, source, false, () => { }, [sourceFile]);
            });
        });
    }
    static create(options, cliOptions, program, tsCompilerHost, compilerHostContext, ngCompilerHost) {
        if (!ngCompilerHost) {
            const usePathMapping = !!options.rootDirs && options.rootDirs.length > 0;
            const context = compilerHostContext || new compiler_host_1.ModuleResolutionHostAdapter(tsCompilerHost);
            ngCompilerHost = usePathMapping ? new path_mapped_compiler_host_1.PathMappedCompilerHost(program, options, context) :
                new compiler_host_1.CompilerHost(program, options, context);
        }
        const transFile = cliOptions.i18nFile;
        const locale = cliOptions.locale;
        let transContent = '';
        if (transFile) {
            if (!locale) {
                throw new Error(`The translation file (${transFile}) locale must be provided. Use the --locale option.`);
            }
            transContent = fs_1.readFileSync(transFile, 'utf8');
        }
        const { compiler: aotCompiler } = compiler.createAotCompiler(ngCompilerHost, {
            debug: options.debug === true,
            translations: transContent,
            i18nFormat: cliOptions.i18nFormat,
            locale: cliOptions.locale,
            excludeFilePattern: options.generateCodeForLibraries === false ? GENERATED_OR_DTS_FILES :
                GENERATED_FILES
        });
        return new CodeGenerator(options, program, tsCompilerHost, aotCompiler, ngCompilerHost);
    }
}
exports.CodeGenerator = CodeGenerator;
function excludeFilePattern(options) {
    return options.generateCodeForLibraries === false ? GENERATED_OR_DTS_FILES : GENERATED_FILES;
}
exports.excludeFilePattern = excludeFilePattern;
//# sourceMappingURL=codegen.js.map